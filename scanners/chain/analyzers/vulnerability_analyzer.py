"""
Vulnerability Analyzer

This module analyzes flow graph to detect vulnerabilities.
"""

import os
import networkx as nx
from typing import List, Dict, Any

from core.config import VULNERABILITY_TYPES


class VulnerabilityAnalyzer:
    """Analyzes flow graph to detect vulnerabilities in taint flow."""
    
    def __init__(self, flow_graph, untrusted_vars, sanitized_vars, llm_nodes):
        self.flow_graph = flow_graph
        self.untrusted_vars = untrusted_vars
        self.sanitized_vars = sanitized_vars
        self.llm_nodes = llm_nodes
        self.vulnerabilities = []
        self.debug = os.environ.get('DEBUG') == "1"
        
        # Enable more detailed logging for debugging
        if self.debug:
            print(f"VulnerabilityAnalyzer initialized with:")
            print(f"  - {len(untrusted_vars)} untrusted variables")
            print(f"  - {len(sanitized_vars)} sanitized variables")
            print(f"  - {len(llm_nodes)} LLM nodes")
        
    def analyze_vulnerabilities(self):
        """Analyze the code for straight paths from untrusted inputs through LLMs to outputs."""
        # Track unique vulnerabilities to avoid duplicates
        unique_vulnerabilities = set()
        
        if self.debug:
            print("\nVulnerabilityAnalyzer.analyze_vulnerabilities starting analysis")
        
        # Extract sanitization nodes
        sanitization_nodes = [node for node in self.flow_graph.nodes() 
                             if isinstance(node, str) and node.startswith('sanitize_')]
        
        # Identify LLM API calls in the code (potential sinks)
        llm_call_nodes = [node for node in self.flow_graph.nodes() 
                         if isinstance(node, str) and node.startswith('llm_call_')]
                         
        # Identify potential output sink nodes
        from core.config import OUTPUT_SINK_PATTERNS, UNSAFE_OUTPUT_OPERATIONS
        output_sink_nodes = []
        
        # Find nodes that match output patterns
        for node in self.flow_graph.nodes():
            if not isinstance(node, str):
                continue
                
            # Check for variables that sound like output sinks
            for pattern in OUTPUT_SINK_PATTERNS:
                if pattern in node.lower():
                    output_sink_nodes.append(node)
                    break
                    
            # Also check for unsafe operations in the node name
            for pattern in UNSAFE_OUTPUT_OPERATIONS:
                if pattern in node.lower():
                    output_sink_nodes.append(node)
                    break
        
        # Also identify LLM output variables as potential stepping stones
        llm_output_vars = [node for node in self.flow_graph.nodes() 
                         if isinstance(node, str) and 
                         self.flow_graph.nodes.get(node, {}).get('llm_output', False)]
                         
        if self.debug:
            print(f"Found {len(output_sink_nodes)} potential output sinks")
            print(f"Found {len(llm_output_vars)} LLM output variables")
        
        # Check if any of our untrusted variables are not in the flow graph
        # and add them as nodes if they're missing
        for var_name in self.untrusted_vars:
            if var_name not in self.flow_graph.nodes():
                self.flow_graph.add_node(var_name, type='source', tainted=True)
                
        # If 'query' exists as a variable but isn't connected to any source,
        # connect it to other untrusted sources as appropriate
        if 'query' in self.flow_graph.nodes() and not list(self.flow_graph.predecessors('query')):
            for source in self.untrusted_vars:
                if source in self.flow_graph.nodes() and source != 'query':
                    self.flow_graph.add_edge(source, 'query', type='taint_flow')
                    break  # Only need one source connection
        
        # Handle flow through multi-step data processing chains (generalized)
        for node in self.flow_graph.nodes():
            if isinstance(node, str) and node in ['contexts', 'documents', 'retrieved_docs']:
                for source in self.untrusted_vars:
                    if source in self.flow_graph.nodes():
                        # Find potential intermediate nodes
                        intermediates = ['query', 'question']
                        for intermediate in intermediates:
                            if intermediate in self.flow_graph.nodes():
                                # Connect source -> intermediate -> retrieval context if needed
                                if not any(pred == source for pred in self.flow_graph.predecessors(intermediate)):
                                    self.flow_graph.add_edge(source, intermediate, type='taint_flow')
                                if not any(pred == intermediate for pred in self.flow_graph.predecessors(node)):
                                    self.flow_graph.add_edge(intermediate, node, type='taint_flow')
                        break  # Only use one source
                
                # Connect this context node to potential LLM inputs
                context_consumers = ['jc', 'context', 'contexts_formatted', 'formatted_context']
                for consumer in context_consumers:
                    if consumer in self.flow_graph.nodes():
                        if not self.flow_graph.has_edge(node, consumer):
                            self.flow_graph.add_edge(node, consumer, type='taint_flow')
                        
                        # Connect the context consumer to LLM calls
                        for llm_node in llm_call_nodes:
                            if not self.flow_graph.has_edge(consumer, llm_node):
                                self.flow_graph.add_edge(consumer, llm_node, type='llm_input')
        
        # Direct path analysis from untrusted sources to LLM calls (simpler approach)
        for source in self.untrusted_vars:
            if source not in self.flow_graph.nodes():
                continue
                
            for llm_node in llm_call_nodes:
                if llm_node not in self.flow_graph.nodes():
                    continue
                    
                # Try to find all paths from this source to the LLM node
                try:
                    # Use a reasonable cutoff to handle complex paths
                    paths = list(nx.all_simple_paths(self.flow_graph, source, llm_node, cutoff=10))
                    
                    # If we found paths, analyze them
                    if paths:
                        if self.debug:
                            print(f"Found {len(paths)} paths from {source} to {llm_node}")
                            for p in paths[:2]:  # Show first couple paths
                                print(f"  Path: {' -> '.join(str(n) for n in p)}")
                                
                        # Check if all paths are sanitized
                        all_sanitized = True
                        for path in paths:
                            if not self._is_path_sanitized(path):
                                all_sanitized = False
                                break
                                
                        if all_sanitized:
                            if self.debug:
                                print(f"  All paths from {source} to {llm_node} are sanitized")
                            continue
                        
                        # At least one path is not sanitized - this is a vulnerability!
                        vuln_id = f"{source}_{llm_node}"
                        if vuln_id not in unique_vulnerabilities:
                            unique_vulnerabilities.add(vuln_id)
                            # Find the first unsanitized path
                            unsanitized_path = next(
                                (p for p in paths if not self._is_path_sanitized(p)),
                                paths[0]  # Default to first path if all are sanitized
                            )
                            self.vulnerabilities.append({
                                'type': VULNERABILITY_TYPES['UNTRUSTED_TO_LLM'],
                                'source': source, 
                                'sink': llm_node,
                                'path': unsanitized_path,
                                'rule_id': 'chain-unsanitized-input',  # Add the rule ID explicitly to match the exclusion pattern
                                'description': f"Untrusted input '{source}' flows to LLM API call without proper sanitization"
                            })
                            if self.debug:
                                print(f"  Registered vulnerability: {source} -> {llm_node}")
                                
                except nx.NetworkXNoPath:
                    # No path exists
                    continue
                except Exception as e:
                    if self.debug:
                        print(f"Error analyzing path from {source} to {llm_node}: {str(e)}")
                        
        # Find all inputs to LLM API calls (keep the original logic as well)
        for llm_node in llm_call_nodes:
            # Get predecessors (inputs to the LLM call)
            llm_inputs = list(self.flow_graph.predecessors(llm_node))
            
            # Check each input for taint
            for input_var in llm_inputs:
                if isinstance(input_var, str) and input_var in self.untrusted_vars:
                    # Skip if this input is in our sanitized variables list
                    if input_var in self.sanitized_vars:
                        continue
                    
                    # Direct connection from untrusted input to LLM - clear vulnerability
                    vuln_id = f"{input_var}_{llm_node}_direct"
                    if vuln_id not in unique_vulnerabilities:
                        unique_vulnerabilities.add(vuln_id)
                        self.vulnerabilities.append({
                            'type': VULNERABILITY_TYPES['UNTRUSTED_TO_LLM'],
                            'source': input_var,
                            'sink': llm_node,
                            'path': [input_var, llm_node],
                            'rule_id': 'chain-unsanitized-input',  # Add the rule ID explicitly to match the exclusion pattern
                            'description': f"Untrusted input '{input_var}' flows directly to LLM API call without proper sanitization"
                        })
                                
        # Also check for sys.argv specifically since it's a common untrusted source
        if 'sys.argv' in self.flow_graph:
            # Find all variables that come from sys.argv
            for node in self.flow_graph.nodes():
                if isinstance(node, str) and node != 'sys.argv':
                    try:
                        if nx.has_path(self.flow_graph, 'sys.argv', node):
                            # Skip if this is in sanitized variables
                            if node in self.sanitized_vars:
                                continue
                                
                            # This variable comes from sys.argv - check if it flows to an LLM
                            for llm_node in llm_call_nodes:
                                # Find paths from this variable to any LLM call
                                if llm_node in self.flow_graph:
                                    try:
                                        paths = list(nx.all_simple_paths(self.flow_graph, node, llm_node))
                                        
                                        # Skip if no paths found
                                        if not paths:
                                            continue
                                        
                                        # Check if all paths are sanitized
                                        all_sanitized = True
                                        for path in paths:
                                            if not self._is_path_sanitized(path):
                                                all_sanitized = False
                                                break
                                        
                                        if all_sanitized:
                                            # All paths are sanitized, no vulnerability
                                            continue
                                        
                                        # Create a vulnerability
                                        vuln_id = f"sys.argv_{node}_{llm_node}"
                                        if vuln_id not in unique_vulnerabilities:
                                            unique_vulnerabilities.add(vuln_id)
                                            self.vulnerabilities.append({
                                                'type': VULNERABILITY_TYPES['SYSTEM_ARGV_TO_LLM'],
                                                'source': f"sys.argv via {node}",
                                                'sink': llm_node,
                                                'path': paths[0],
                                                'rule_id': 'chain-unsanitized-input',  # Add the rule ID explicitly to match the exclusion pattern
                                                'description': f"Command line argument from sys.argv flows to LLM without proper sanitization"
                                            })
                                    except nx.NetworkXNoPath:
                                        # No path exists
                                        pass
                    except Exception:
                        # Ignore errors in path finding
                        pass
                                
        # Analyze complete chains (input -> LLM -> output)
        # For each output sink, check if there's a path from LLM output to it
        for output_sink in output_sink_nodes:
            # Skip if this output is in our sanitized variables list
            if output_sink in self.sanitized_vars:
                continue
            
            # First find complete unsafe chains (input -> LLM -> output)
            for source in self.untrusted_vars:
                if source in self.flow_graph and output_sink in self.flow_graph:
                    try:
                        # Find all simple paths from source to output
                        all_paths = list(nx.all_simple_paths(self.flow_graph, source, output_sink, cutoff=15))
                        
                        # Filter to only include paths that contain an LLM node
                        llm_paths = [path for path in all_paths if self._path_contains_llm(path)]
                        
                        # Skip if no valid paths
                        if not llm_paths:
                            continue
                            
                        # Check if all paths are sanitized
                        all_sanitized = True
                        for path in llm_paths:
                            if not self._is_path_sanitized(path):
                                all_sanitized = False
                                break
                        
                        if all_sanitized:
                            # All paths are sanitized, no vulnerability
                            continue
                            
                        # Found at least one unsanitized path in the complete chain
                        vuln_id = f"complete_chain_{source}_{output_sink}"
                        
                        if vuln_id not in unique_vulnerabilities:
                            unique_vulnerabilities.add(vuln_id)
                            # Find the first unsanitized path to report
                            unsanitized_path = next(
                                (path for path in llm_paths if not self._is_path_sanitized(path)),
                                llm_paths[0]
                            )
                            
                            # Check if this path contains at least one LLM call node
                            llm_call_in_path = any(node.startswith('llm_call_') for node in unsanitized_path)
                            
                            self.vulnerabilities.append({
                                'type': VULNERABILITY_TYPES['UNSAFE_COMPLETE_CHAIN'],
                                'source': source,
                                'sink': output_sink,
                                'path': unsanitized_path,
                                'line': node.lineno if hasattr(node, 'lineno') else 0,
                                'rule_id': 'chain-unsanitized-complete-chain',  # Add the rule ID explicitly to match the exclusion pattern
                                'description': f"Unsafe complete chain from untrusted input '{source}' through LLM to output '{output_sink}' without proper sanitization"
                            })
                            
                            if self.debug:
                                print(f"Found complete unsafe chain: {source} -> {output_sink}")
                                print(f"  Path: {' -> '.join(str(n) for n in unsanitized_path[:10])}{'...' if len(unsanitized_path) > 10 else ''}")
                                
                    except nx.NetworkXNoPath:
                        # No path exists
                        continue
                    except nx.NetworkXError:
                        # Some other graph error
                        continue
                        
            # Also check LLM output to unsafe output paths independently
            for llm_var in llm_output_vars:
                if llm_var in self.flow_graph and output_sink in self.flow_graph:
                    try:
                        # Find all simple paths from LLM output to output sink
                        paths = list(nx.all_simple_paths(self.flow_graph, llm_var, output_sink, cutoff=10))
                        
                        # Skip if no paths
                        if not paths:
                            continue
                            
                        # Check if all paths are sanitized after LLM output
                        post_llm_sanitized = True
                        for path in paths:
                            # For this check, we're only concerned with sanitization after the LLM output
                            if not self._is_path_post_llm_sanitized(path):
                                post_llm_sanitized = False
                                break
                                
                        if post_llm_sanitized:
                            # All paths are sanitized after LLM output
                            continue
                            
                        # Found an unsanitized LLM-to-output path
                        vuln_id = f"llm_to_output_{llm_var}_{output_sink}"
                        
                        if vuln_id not in unique_vulnerabilities:
                            unique_vulnerabilities.add(vuln_id)
                            self.vulnerabilities.append({
                                'type': VULNERABILITY_TYPES['LLM_TO_UNSAFE_OUTPUT'],
                                'source': llm_var,
                                'sink': output_sink,
                                'path': paths[0],
                                'line': next((self.flow_graph.nodes[n].get('line', 0) for n in paths[0] if isinstance(n, str) and n == output_sink), 0),
                                'description': f"LLM output '{llm_var}' flows to potentially unsafe operation '{output_sink}' without proper sanitization"
                            })
                            
                            if self.debug:
                                print(f"Found LLM-to-output unsafe path: {llm_var} -> {output_sink}")
                                
                    except nx.NetworkXNoPath:
                        # No path exists
                        continue
                    except nx.NetworkXError:
                        # Some other graph error
                        continue

        # Keep the original code that looks for paths from source to standard output variables
        standard_output_vars = set()
        for node in self.flow_graph.nodes():
            # Consider variables that are used as final outputs or start with 'output' or 'result'
            if isinstance(node, str) and (node.startswith('output') or node.startswith('result')):
                standard_output_vars.add(node)

        # For each standard output, check if there's a path from an untrusted source
        for output in standard_output_vars:
            # Skip if this output is in our sanitized variables list or we already found it
            if output in self.sanitized_vars or output in output_sink_nodes:
                continue
                
            for source in self.untrusted_vars:
                if source in self.flow_graph and output in self.flow_graph:
                    try:
                        # Find all simple paths from source to output
                        all_paths = list(nx.all_simple_paths(self.flow_graph, source, output))
                        
                        # Filter to only include paths that contain an LLM node
                        llm_paths = [path for path in all_paths if self._path_contains_llm(path)]
                        
                        # Skip if no valid paths
                        if not llm_paths:
                            continue
                            
                        # Check if all paths are sanitized
                        all_sanitized = True
                        for path in llm_paths:
                            if not self._is_path_sanitized(path):
                                all_sanitized = False
                                break
                        
                        if all_sanitized:
                            # All paths are sanitized, no vulnerability
                            continue
                            
                        # Found at least one unsanitized path
                        vuln_id = f"{source}_{output}"
                        
                        if vuln_id not in unique_vulnerabilities:
                            unique_vulnerabilities.add(vuln_id)
                            # Find the first unsanitized path to report
                            unsanitized_path = next(
                                (path for path in llm_paths if not self._is_path_sanitized(path)),
                                llm_paths[0]
                            )
                            self.vulnerabilities.append({
                                'type': VULNERABILITY_TYPES['LLM_STRAIGHT_PATH'],
                                'source': source,
                                'sink': output,
                                'path': unsanitized_path,
                                'rule_id': 'chain-unsanitized-input',  # Add the rule ID explicitly to match the exclusion pattern
                                'description': f"Straight path from untrusted input '{source}' through LLM to output '{output}'"
                            })
                                
                    except nx.NetworkXNoPath:
                        # No path exists
                        pass

        return self.vulnerabilities
        
    def _path_contains_llm(self, path):
        """Check if a path contains at least one LLM-related node."""
        return any(node in self.llm_nodes for node in path)

    def _is_path_sanitized(self, path):
        """Check if a path contains a sanitization node or involves sanitized variables."""
        # Check if the path contains a sanitization point directly
        direct_sanitization = any(
            isinstance(node, str) and (
                node.startswith('sanitize_') or 
                node in self.sanitized_vars
            )
            for node in path
        )
        
        if direct_sanitization:
            return True
        
        # Check for sanitization relationships in the path
        # This handles cases where sanitization wasn't directly in the path
        # but affects variables in the path
        for i, node in enumerate(path[:-1]):
            if node in self.untrusted_vars and node not in self.sanitized_vars:
                # For each tainted node, check if it's connected to a sanitization node
                # that might not be directly in the path
                for sanitize_node in self.flow_graph.nodes():
                    if isinstance(sanitize_node, str) and sanitize_node.startswith('sanitize_'):
                        # Check if this sanitization node affects any variable in our path
                        for successor in self.flow_graph.successors(sanitize_node):
                            if successor in path[i:]:
                                return True
        
        # Check for sanitization after LLM nodes
        llm_indices = [i for i, node in enumerate(path) 
                         if isinstance(node, str) and (
                            node.startswith('llm_call_') or 
                            self.flow_graph.nodes.get(node, {}).get('llm_output', False)
                         )]
        
        # If we found LLM nodes, check if there's sanitization afterwards
        if llm_indices:
            last_llm_index = max(llm_indices)
            # Check if there's sanitization in the path after the last LLM node
            post_llm_path = path[last_llm_index:]
            if any(isinstance(node, str) and (
                   node.startswith('sanitize_') or 
                   node in self.sanitized_vars)
                  for node in post_llm_path[1:]):  # Skip the LLM node itself
                return True
                
            # Also check for connections to sanitization nodes after the LLM
            for i, node in enumerate(post_llm_path[1:], start=last_llm_index+1):
                # For each node after LLM, check if it's connected to a sanitization node
                for sanitize_node in self.flow_graph.nodes():
                    if isinstance(sanitize_node, str) and sanitize_node.startswith('sanitize_'):
                        # Check if this sanitization node affects any variable in our post-LLM path
                        for successor in self.flow_graph.successors(sanitize_node):
                            if successor in path[i:]:
                                return True
        
        # No sanitization found
        return False
        
    def _is_path_post_llm_sanitized(self, path):
        """Check if a path is sanitized after LLM output."""
        # This specifically checks for sanitization AFTER LLM output
        # and is used for LLM output -> sink paths
        
        # There must be at least one sanitization node in the path
        direct_sanitization = any(
            isinstance(node, str) and (
                node.startswith('sanitize_') or 
                node in self.sanitized_vars
            )
            for node in path[1:]  # Skip the first node (LLM output)
        )
        
        if direct_sanitization:
            return True
            
        # Check for connections to sanitization nodes
        for i, node in enumerate(path[:-1]):
            # For each node, check if it's connected to a sanitization node
            for sanitize_node in self.flow_graph.nodes():
                if isinstance(sanitize_node, str) and sanitize_node.startswith('sanitize_'):
                    # Check if this sanitization node affects any subsequent variable in our path
                    for successor in self.flow_graph.successors(sanitize_node):
                        if successor in path[i+1:]:
                            return True
                            
        # Also check for output sanitization functions
        from core.config import OUTPUT_SANITIZATION_FUNCTIONS
        for i, node in enumerate(path):
            if isinstance(node, str):
                for sanitize_pattern in OUTPUT_SANITIZATION_FUNCTIONS:
                    if sanitize_pattern in node:
                        return True
        
        # No sanitization found
        return False